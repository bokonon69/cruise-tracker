<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>lloydkade live tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 380px 1fr; grid-template-rows: auto 1fr auto; height: 100%; }
    header { grid-column: 1 / span 2; padding: .6rem .9rem; border-bottom: 1px solid #e5e7eb; display:flex; gap:.75rem; align-items: center; flex-wrap: wrap; }
    aside { border-right: 1px solid #e5e7eb; overflow: auto; }
    main { position: relative; }
    #map { position:absolute; inset:0; }
    footer { grid-column: 1 / span 2; border-top: 1px solid #e5e7eb; padding: .5rem .9rem; display:flex; justify-content: space-between; gap:.75rem; font-size: 14px; }
    .controls label { margin-right: .5rem; font-size: 14px; }
    .list { padding:.5rem; }
    .list-item { padding:.4rem .3rem; border-bottom: 1px dashed #eee; cursor: pointer; }
    .list-item:hover { background:#fafafa; }
    .error { color: #b91c1c; }
    button { padding:.35rem .6rem; border-radius:.5rem; border:1px solid #d1d5db; background:white; cursor:pointer; }
    select, input[type="number"], input[type="text"] { padding:.25rem .35rem; }
    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:.25rem .5rem; }
    .muted { opacity:.75; font-size:12px; }
    .row { display:flex; gap:.5rem; align-items:center; margin-top:.25rem; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <strong>lloydkade live tracker</strong>
      <div class="controls">
        <label>bbox:
          <select id="bbox">
            <option value="gewenst">gewenst</option>
            <option value="normaal">normaal</option>
            <option value="smal">smal</option>
            <option value="ruim">ruim</option>
            <option value="custom">custom</option>
          </select>
        </label>
        <label>toon bbox: <input id="showbbox" type="checkbox" checked /></label>
        <label>interval (s): <input id="interval" type="number" min="2" max="60" step="1" value="5" /></label>
        <label>ttl (s): <input id="ttl" type="number" min="10" max="300" step="5" value="45" /></label>
        <label>trail (punten): <input id="trailLen" type="number" min="3" max="30" step="1" value="8" /></label>
        <button id="start">start</button>
        <button id="stop" disabled>stop</button>
        <span id="status"></span>
      </div>
    </header>
    <aside>
      <div style="padding:.5rem" id="customPanel" class="muted">
        <div><strong>custom bbox</strong></div>
        <div class="grid">
          <label>minLat <input id="minLat" type="number" step="0.0001" /></label>
          <label>maxLat <input id="maxLat" type="number" step="0.0001" /></label>
          <label>minLon <input id="minLon" type="number" step="0.0001" /></label>
          <label>maxLon <input id="maxLon" type="number" step="0.0001" /></label>
        </div>
        <div class="row">
          <button id="applyFromMap">use map bbox</button>
          <button id="applyToMap">update rectangle</button>
        </div>
        <hr/>
        <div><strong>profielen opslaan</strong></div>
        <div class="row">
          <input id="profileName" type="text" placeholder="profielnaam" />
          <button id="saveProfile">save</button>
          <button id="setDefault">set default</button>
        </div>
        <div class="row">
          <label>laad profiel: <select id="savedProfiles"></select></label>
          <button id="deleteProfile">delete</button>
        </div>
        <div class="muted">profielen worden lokaal opgeslagen (browser localStorage)</div>
        <hr/>
      </div>
      <div class="list" id="list"></div>
    </aside>
    <main>
      <div id="map"></div>
    </main>
    <footer>
      <div>schepen: <span id="count">0</span></div>
      <div>latency: <span id="latency">–</span> ms</div>
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    const DEFAULTS = { minLat: 51.9038, maxLat: 51.9090, minLon: 4.4550, maxLon: 4.4720 };
    const BASE_PROFILES = {
      smal:   { minLat: 51.9056, maxLat: 51.9075, minLon: 4.4585, maxLon: 4.4680 },
      normaal:{ ...DEFAULTS },
      ruim:   { minLat: 51.9000, maxLat: 51.9140, minLon: 4.4450, maxLon: 4.4850 },
      gewenst:{ minLat: 51.9039, maxLat: 51.9078, minLon: 4.4548, maxLon: 4.4725 }
    };

    // persistent store + arrows + trails
    const STORE = new Map(); // mmsi -> { ...v, lastSeen, trail: [[lat,lon], ...] }
    let TTL_MS = 45000;
    let TRAIL_LEN = 8;

    const map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    let markers = new Map();   // mmsi -> circleMarker
    let trails = new Map();    // mmsi -> polyline
    let arrows = new Map();    // mmsi -> arrow polyline
    let bboxRect = null;       // rectangle overlay
    let pollTimer = null;

    // saved profiles in localStorage
    const LS_KEY = 'lloydkade_profiles_v1';
    const LS_DEFAULT = 'lloydkade_default_profile_v1';
    function loadSavedProfiles() {
      try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch { return {}; }
    }
    function saveSavedProfiles(obj) {
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }
    function getDefaultProfileName() {
      return localStorage.getItem(LS_DEFAULT) || null;
    }
    function setDefaultProfileName(name) {
      localStorage.setItem(LS_DEFAULT, name);
    }

    function populateSavedProfilesSelect() {
      const sel = document.getElementById('savedProfiles');
      sel.innerHTML = '';
      const saved = loadSavedProfiles();
      const names = Object.keys(saved).sort();
      for (const n of names) {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      }
    }

    // --- bbox helpers ---
    function fitTo(b) {
      const sw = L.latLng(b.minLat, b.minLon);
      const ne = L.latLng(b.maxLat, b.maxLon);
      map.fitBounds(L.latLngBounds(sw, ne));
    }

    function drawBbox(b, editable=false) {
      if (bboxRect) { map.removeLayer(bboxRect); bboxRect = null; }
      const show = document.getElementById('showbbox').checked;
      if (!show) return;
      const sw = L.latLng(b.minLat, b.minLon);
      const ne = L.latLng(b.maxLat, b.maxLon);
      bboxRect = L.rectangle([sw, ne], { weight: 1, dashArray: '4,4', fillOpacity: 0.03 });
      bboxRect.addTo(map);
      if (editable && bboxRect.editing && typeof bboxRect.editing.enable === 'function') {
        bboxRect.editing.enable();
        bboxRect.on('edit', () => {
          const bb = bboxRect.getBounds();
          const s = bb.getSouthWest();
          const n = bb.getNorthEast();
          setInputs({ minLat: s.lat, minLon: s.lng, maxLat: n.lat, maxLon: n.lng });
        });
      }
    }

    function setInputs(b) {
      document.getElementById('minLat').value = (b.minLat||'').toFixed ? b.minLat.toFixed(4) : b.minLat;
      document.getElementById('maxLat').value = (b.maxLat||'').toFixed ? b.maxLat.toFixed(4) : b.maxLat;
      document.getElementById('minLon').value = (b.minLon||'').toFixed ? b.minLon.toFixed(4) : b.minLon;
      document.getElementById('maxLon').value = (b.maxLon||'').toFixed ? b.maxLon.toFixed(4) : b.maxLon;
    }
    function getInputs() {
      return {
        minLat: parseFloat(document.getElementById('minLat').value),
        maxLat: parseFloat(document.getElementById('maxLat').value),
        minLon: parseFloat(document.getElementById('minLon').value),
        maxLon: parseFloat(document.getElementById('maxLon').value)
      };
    }

    function currentBbox() {
      const sel = document.getElementById('bbox').value;
      if (sel === 'custom') {
        const v = getInputs();
        return {
          minLat: v.minLat || DEFAULTS.minLat,
          maxLat: v.maxLat || DEFAULTS.maxLat,
          minLon: v.minLon || DEFAULTS.minLon,
          maxLon: v.maxLon || DEFAULTS.maxLon
        };
      }
      // base or saved profile
      const saved = loadSavedProfiles();
      if (saved[sel]) return saved[sel];
      return BASE_PROFILES[sel] || BASE_PROFILES.gewenst;
    }

    // initialise selection by default profile if exists
    (function initDefaultProfile() {
      populateSavedProfilesSelect();
      const def = getDefaultProfileName();
      const baseNames = ['gewenst','normaal','smal','ruim','custom'];
      const sel = document.getElementById('bbox');
      if (def && !baseNames.includes(def)) {
        const opt = document.createElement('option');
        opt.value = def; opt.textContent = def + ' (saved)';
        sel.insertBefore(opt, sel.firstChild);
        sel.value = def;
        const b = currentBbox();
        setInputs(b);
        fitTo(b); drawBbox(b, false);
      } else {
        fitTo(BASE_PROFILES.gewenst); drawBbox(BASE_PROFILES.gewenst);
        setInputs(BASE_PROFILES.gewenst);
      }
    })();

    function fmt(n, d=1){ return (n==null || Number.isNaN(n)) ? '–' : Number(n).toFixed(d); }
    const vf = (mmsi) => `https://www.vesselfinder.com/?mmsi=${encodeURIComponent(mmsi)}`;

    async function snapshot(bbox, windowMs=6000) {
      const url = new URL('/.netlify/functions/ais-snapshot', window.location.origin);
      Object.entries({ ...bbox, windowMs }).forEach(([k,v]) => url.searchParams.set(k, v));
      const t0 = performance.now();
      const res = await fetch(url, { cache: 'no-store' });
      const latency = Math.round(performance.now() - t0);
      document.getElementById('latency').textContent = latency;
      if (!res.ok) throw new Error(`http ${res.status}`);
      return res.json();
    }

    function updateStore(items, bbox) {
      const now = Date.now();
      TRAIL_LEN = Math.min(Math.max(parseInt(document.getElementById('trailLen').value,10)||8,3),30);
      for (const v of items) {
        if (!v.mmsi) continue;
        const prev = STORE.get(v.mmsi) || {};
        const trail = (prev.trail || []).slice(-TRAIL_LEN + 1);
        trail.push([v.lat, v.lon]);
        STORE.set(v.mmsi, { ...prev, ...v, lastSeen: now, trail });
      }
      for (const [mmsi, rec] of STORE) {
        const expired = now - (rec.lastSeen || 0) > TTL_MS;
        const outside = rec.lat < bbox.minLat || rec.lat > bbox.maxLat
                     || rec.lon < bbox.minLon || rec.lon > bbox.maxLon;
        if (expired || outside) {
          STORE.delete(mmsi);
          const mk = markers.get(mmsi); if (mk) { map.removeLayer(mk); markers.delete(mmsi); }
          const pl = trails.get(mmsi);  if (pl) { map.removeLayer(pl); trails.delete(mmsi); }
          const ar = arrows.get(mmsi);  if (ar) { map.removeLayer(ar); arrows.delete(mmsi); }
        }
      }
    }

    function renderList(items) {
      const el = document.getElementById('list');
      el.innerHTML = '';
      items.sort((a,b) => (b.sog||0)-(a.sog||0));
      for (const v of items) {
        const age = Date.now() - (v.lastSeen||0);
        const frac = Math.min(Math.max(age / TTL_MS, 0), 1);
        const dim = (1 - frac).toFixed(2);
        const div = document.createElement('div');
        div.className = 'list-item';
        div.style.opacity = dim;
        const since = Math.round(age/1000);
        div.textContent = `${v.name || 'onbekend'} · MMSI ${v.mmsi || '–'} · SOG ${fmt(v.sog)} kn · COG ${fmt(v.cog)} · ${since}s geleden`;
        div.onclick = () => {
          const m = markers.get(v.mmsi);
          if (m) { map.setView(m.getLatLng(), 16); m.openPopup(); }
        };
        el.appendChild(div);
      }
      document.getElementById('count').textContent = String(items.length);
    }

    // helper to compute arrow endpoint from lat/lon and cog (degrees)
    function endpointFromCog(lat, lon, cogDeg, meters=80) {
      if (!Number.isFinite(cogDeg)) return [lat, lon];
      const R = 6378137; // meters
      const brng = cogDeg * Math.PI/180;
      const lat1 = lat * Math.PI/180;
      const lon1 = lon * Math.PI/180;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(meters/R) + Math.cos(lat1)*Math.sin(meters/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(meters/R)*Math.cos(lat1), Math.cos(meters/R)-Math.sin(lat1)*Math.sin(lat2));
      return [lat2*180/Math.PI, lon2*180/Math.PI];
    }

    function renderGraphics(items) {
      const now = Date.now();
      for (const v of items) {
        const latlng = [v.lat, v.lon];
        const age = now - (v.lastSeen||0);
        const frac = Math.min(Math.max(age / TTL_MS, 0), 1);
        const opacity = Math.max(0.25, 1 - frac * 0.85);
        const radius = 6 - Math.floor(frac * 2);

        const popup = `<strong>${v.name || 'onbekend'}</strong><br/>MMSI: ${v.mmsi || '–'}<br/>Type: ${v.type || '–'}<br/>SOG: ${fmt(v.sog)} kn<br/>COG: ${fmt(v.cog)}°<br/><a href="${vf(v.mmsi||'')}" target="_blank" rel="noopener">open in vesselfinder</a>`;

        let mk = markers.get(v.mmsi);
        if (mk) {
          mk.setLatLng(latlng).setStyle({ opacity, fillOpacity: opacity, radius });
          mk.bindPopup(popup);
        } else {
          mk = L.circleMarker(latlng, { radius, weight: 1, opacity, fillOpacity: opacity });
          mk.addTo(map).bindPopup(popup);
          markers.set(v.mmsi, mk);
        }

        // trail polyline
        let pl = trails.get(v.mmsi);
        const tl = (v.trail || []).map(([la,lo]) => [la,lo]);
        if (pl) {
          pl.setLatLngs(tl).setStyle({ opacity: Math.max(0.2, opacity - 0.2) });
        } else {
          pl = L.polyline(tl, { weight: 2, opacity: 0.6 });
          pl.addTo(map);
          trails.set(v.mmsi, pl);
        }

        // direction arrow line from position to endpoint
        let ar = arrows.get(v.mmsi);
        const end = endpointFromCog(v.lat, v.lon, v.cog, 100); // 100m arrow
        if (ar) {
          ar.setLatLngs([latlng, end]).setStyle({ opacity: Math.max(0.3, opacity) });
        } else {
          ar = L.polyline([latlng, end], { weight: 2, opacity: 0.8 });
          ar.addTo(map);
          arrows.set(v.mmsi, ar);
        }
      }
    }

    function status(msg, isError=false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = isError ? 'error' : '';
    }

    function currentIntervalMs() { return Math.min(Math.max(parseInt(document.getElementById('interval').value,10)||5,2),60)*1000; }

    async function tick() {
      const bbox = currentBbox();
      try {
        const res = await snapshot(bbox, 6000);
        status(`ok (${res.count})`);
        updateStore(res.data || [], bbox);
        const active = Array.from(STORE.values());
        renderGraphics(active);
        renderList(active);
      } catch (e) {
        status(`functie niet bereikbaar (${e.message}). demo-modus actief`, true);
        demoOnce();
      }
    }

    function start() {
      if (pollTimer) return;
      TTL_MS = Math.min(Math.max((parseInt(document.getElementById('ttl').value,10)||45)*1000, 5000), 600000);
      document.getElementById('start').disabled = true;
      document.getElementById('stop').disabled = false;
      tick();
      pollTimer = setInterval(tick, currentIntervalMs());
    }

    function stop() {
      if (!pollTimer) return;
      clearInterval(pollTimer);
      pollTimer = null;
      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;
      status('gestopt');
    }

    document.getElementById('start').onclick = start;
    document.getElementById('stop').onclick = stop;
    document.getElementById('bbox').onchange = () => {
      const sel = document.getElementById('bbox').value;
      document.getElementById('customPanel').style.display = (sel === 'custom') ? 'block' : 'none';
      const b = currentBbox();
      fitTo(b);
      drawBbox(b, sel === 'custom');
      if (sel !== 'custom') setInputs(b);
    };
    document.getElementById('showbbox').onchange = () => { drawBbox(currentBbox(), document.getElementById('bbox').value === 'custom'); };

    document.getElementById('applyFromMap').onclick = () => {
      if (!bboxRect) return;
      const bb = bboxRect.getBounds();
      const s = bb.getSouthWest();
      const n = bb.getNorthEast();
      setInputs({ minLat: s.lat, minLon: s.lng, maxLat: n.lat, maxLon: n.lng });
    };
    document.getElementById('applyToMap').onclick = () => {
      const b = currentBbox();
      drawBbox(b, true);
      fitTo(b);
    };

    // profile save/load/delete/default
    document.getElementById('saveProfile').onclick = () => {
      const name = (document.getElementById('profileName').value || '').trim();
      if (!name) return alert('voer een profielnaam in');
      const vals = getInputs();
      const saved = loadSavedProfiles();
      saved[name] = vals;
      saveSavedProfiles(saved);
      populateSavedProfilesSelect();
      // voeg optie toe in selector voor direct gebruik
      const sel = document.getElementById('bbox');
      let opt = Array.from(sel.options).find(o => o.value === name);
      if (!opt) {
        opt = document.createElement('option');
        opt.value = name; opt.textContent = name + ' (saved)';
        sel.appendChild(opt);
      }
      sel.value = name;
    };
    document.getElementById('setDefault').onclick = () => {
      const sel = document.getElementById('bbox').value;
      if (sel === 'custom') return alert('sla het custom profiel eerst op met een naam');
      setDefaultProfileName(sel);
      alert('default profiel gezet: ' + sel);
    };
    document.getElementById('deleteProfile').onclick = () => {
      const selSaved = document.getElementById('savedProfiles').value;
      if (!selSaved) return;
      const saved = loadSavedProfiles();
      delete saved[selSaved];
      saveSavedProfiles(saved);
      populateSavedProfilesSelect();
      // verwijder uit hoofdselector als aanwezig
      const mainSel = document.getElementById('bbox');
      for (const o of Array.from(mainSel.options)) {
        if (o.value === selSaved) { mainSel.removeChild(o); break; }
      }
    };
    document.getElementById('savedProfiles').onchange = (e) => {
      const name = e.target.value;
      const saved = loadSavedProfiles();
      if (saved[name]) {
        setInputs(saved[name]);
        const mainSel = document.getElementById('bbox');
        let opt = Array.from(mainSel.options).find(o => o.value === name);
        if (!opt) {
          opt = document.createElement('option');
          opt.value = name; opt.textContent = name + ' (saved)';
          mainSel.appendChild(opt);
        }
        mainSel.value = name;
        const b = currentBbox();
        fitTo(b); drawBbox(b);
      }
    };

    // initialise custom panel with current bbox
    setInputs(BASE_PROFILES.gewenst);
    document.getElementById('customPanel').style.display = (document.getElementById('bbox').value === 'custom') ? 'block' : 'none';

    function demoOnce() {
      const b = currentBbox();
      const rnd = (min, max) => min + Math.random() * (max - min);
      const names = ['Demo I', 'Demo II', 'Demo III', 'Demo IV'];
      const now = Date.now();
      const items = names.map((n, i) => ({
        mmsi: `999000${i+1}`,
        name: n,
        lat: rnd(b.minLat, b.maxLat),
        lon: rnd(b.minLon, b.maxLon),
        sog: Math.round(rnd(0, 18)*10)/10,
        cog: Math.round(rnd(0, 359)),
        type: 'Demo',
        ts: now,
        lastSeen: now,
        trail: [[rnd(b.minLat, b.maxLat), rnd(b.minLon, b.maxLon)]]
      }));
      for (const v of items) STORE.set(v.mmsi, v);
      renderGraphics(items);
      renderList(items);
    }
  </script>
</body>
</html>
