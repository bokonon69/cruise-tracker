<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>lloydkade live tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    :root {
      --header-h: 56px;
      --footer-h: 40px;
      --panel-w: 380px;
      --panel-w-mobile: min(88vw, 360px);
      --tap-size: 44px;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #app {
      display: grid;
      grid-template-columns: var(--panel-w) 1fr;
      grid-template-rows: var(--header-h) 1fr var(--footer-h);
      height: 100dvh;
      overflow: hidden;
    }
    header {
      grid-column: 1 / span 2;
      display:flex; align-items:center; gap:.6rem; padding: .4rem .6rem;
      border-bottom: 1px solid #e5e7eb; position: sticky; top: 0; background: #fff; z-index: 3;
    }
    .brand { font-weight: 700; }
    .controls { display:flex; flex-wrap:wrap; align-items:center; gap:.5rem; }
    .controls label { font-size: 14px; display:flex; align-items:center; gap:.3rem; }
    .controls select, .controls input[type="number"], .controls input[type="text"] { padding:.35rem .45rem; font-size:14px; min-height: var(--tap-size); }
    button { padding:.5rem .7rem; border-radius:.6rem; border:1px solid #d1d5db; background:#fff; cursor:pointer; min-height: var(--tap-size); }
    button.active { background:#111827; color:#fff; border-color:#111827; }
    aside { border-right: 1px solid #e5e7eb; overflow: auto; position: relative; z-index: 2; background:#fff; }
    main { position: relative; }
    #map { position:absolute; inset:0; touch-action: none; }
    footer { grid-column: 1 / span 2; border-top: 1px solid #e5e7eb; padding: .4rem .6rem; display:flex; justify-content: space-between; align-items:center; gap:.5rem; font-size: 14px; background:#fff; position: sticky; bottom: 0; z-index: 3; }
    .list { padding:.5rem; }
    .list-item { padding:.5rem .35rem; border-bottom: 1px dashed #eee; cursor: pointer; }
    .list-item:hover { background:#fafafa; }
    .error { color: #b91c1c; }
    .grid { display:grid; grid-template-columns: repeat(2, 1fr); gap:.25rem .5rem; }
    .muted { opacity:.75; font-size:12px; }
    .row { display:flex; gap:.5rem; align-items:center; margin-top:.25rem; }
    /* Drawer toggle on mobile */
    .burger { display:none; width: var(--tap-size); height: var(--tap-size); align-items:center; justify-content:center; border-radius:.6rem; }
    .burger svg { width:22px; height:22px; }
    /* Mobile layout */
    @media (max-width: 768px) {
      #app {
        grid-template-columns: 1fr;
      }
      aside {
        position: absolute;
        top: var(--header-h);
        bottom: var(--footer-h);
        left: 0;
        width: var(--panel-w-mobile);
        transform: translateX(-105%);
        transition: transform .2s ease-out, box-shadow .2s ease-out;
        box-shadow: 0 10px 30px rgba(0,0,0,.12);
        border-right: 0;
        border-top: 1px solid #eee;
        border-bottom: 1px solid #eee;
        border-radius: 0 .75rem .75rem 0;
      }
      aside.open {
        transform: translateX(0);
      }
      .burger { display:flex; }
      header { gap:.4rem; }
      .controls { gap:.35rem; }
      .controls label { font-size: 13px; }
      .controls button { padding:.45rem .6rem; }
      .controls select, .controls input[type="number"], .controls input[type="text"] { min-width: 84px; }
    }
    /* Larger popup text for mobile */
    .leaflet-popup-content { font-size: 15px; line-height: 1.25; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <button id="burger" class="burger" aria-label="toggle panel" title="toggle panel">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg>
      </button>
      <div class="brand">lloydkade live tracker</div>
      <div class="controls">
        <label>bbox:
          <select id="bbox">
            <option value="gewenst">gewenst</option>
            <option value="normaal">normaal</option>
            <option value="smal">smal</option>
            <option value="ruim">ruim</option>
            <option value="custom">custom</option>
          </select>
        </label>
        <label>show bbox <input id="showbbox" type="checkbox" checked /></label>
        <label>interval (s) <input id="interval" type="number" min="2" max="60" step="1" value="5" /></label>
        <label>ttl (s) <input id="ttl" type="number" min="10" max="300" step="5" value="45" /></label>
        <label>trail <input id="trailLen" type="number" min="3" max="30" step="1" value="8" /></label>
        <button id="presetHide" class="active">hide moored</button>
        <button id="presetShow">show all</button>
        <button id="start">start</button>
        <button id="stop" disabled>stop</button>
        <span id="status"></span>
      </div>
    </header>
    <aside id="panel">
      <div style="padding:.5rem" id="customPanel" class="muted">
        <div><strong>custom bbox</strong></div>
        <div class="grid">
          <label>minLat <input id="minLat" type="number" step="0.0001" /></label>
          <label>maxLat <input id="maxLat" type="number" step="0.0001" /></label>
          <label>minLon <input id="minLon" type="number" step="0.0001" /></label>
          <label>maxLon <input id="maxLon" type="number" step="0.0001" /></label>
        </div>
        <div class="row">
          <button id="applyFromMap">use map bbox</button>
          <button id="applyToMap">update rectangle</button>
        </div>
        <hr/>
        <div><strong>profiles</strong></div>
        <div class="row">
          <input id="profileName" type="text" placeholder="name" />
          <button id="saveProfile">save</button>
          <button id="setDefault">set default</button>
        </div>
        <div class="row">
          <label>load <select id="savedProfiles"></select></label>
          <button id="deleteProfile">delete</button>
        </div>
        <div class="muted">saved locally (this device)</div>
        <hr/>
      </div>
      <div class="list" id="list"></div>
    </aside>
    <main>
      <div id="map"></div>
    </main>
    <footer>
      <div>ships: <span id="count">0</span></div>
      <div>mode: <span id="mode">hide moored</span></div>
      <div>latency: <span id="latency">–</span> ms</div>
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script>
    // basic feature detection
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    const DEFAULTS = { minLat: 51.9038, maxLat: 51.9090, minLon: 4.4550, maxLon: 4.4720 };
    const BASE_PROFILES = {
      smal:   { minLat: 51.9056, maxLat: 51.9075, minLon: 4.4585, maxLon: 4.4680 },
      normaal:{ ...DEFAULTS },
      ruim:   { minLat: 51.9000, maxLat: 51.9140, minLon: 4.4450, maxLon: 4.4850 },
      gewenst:{ minLat: 51.9039, maxLat: 51.9078, minLon: 4.4548, maxLon: 4.4725 }
    };

    // persistent store
    const STORE = new Map(); // mmsi -> { ...v, lastSeen, trail: [[lat,lon], ...] }
    let TTL_MS = isMobile ? 35000 : 45000;
    let TRAIL_LEN = isMobile ? 6 : 8;
    let SHOW_ALL = false; // default hide moored on mobile & desktop
    let DRAWER_OPEN = !isMobile; // open panel by default on desktop, closed on mobile

    const LS_MODE = 'lloyd_mode_v1';
    const LS_DRAWER = 'lloyd_drawer_v1';

    // restore persisted mode/drawer
    try {
      const savedMode = localStorage.getItem(LS_MODE);
      if (savedMode === 'show') SHOW_ALL = true;
      const savedDrawer = localStorage.getItem(LS_DRAWER);
      if (savedDrawer === 'open') DRAWER_OPEN = true;
      if (savedDrawer === 'closed') DRAWER_OPEN = false;
    } catch {}

    const map = L.map('map', { tap: true, tapTolerance: 10, inertia: true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    let markers = new Map();   // mmsi -> circleMarker
    let trails = new Map();    // mmsi -> polyline
    let arrows = new Map();    // mmsi -> arrow polyline
    let bboxRect = null;       // rectangle overlay
    let pollTimer = null;

    // saved profiles in localStorage
    const LS_KEY = 'lloydkade_profiles_v1';
    const LS_DEFAULT = 'lloydkade_default_profile_v1';
    function loadSavedProfiles() { try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch { return {}; } }
    function saveSavedProfiles(obj) { localStorage.setItem(LS_KEY, JSON.stringify(obj)); }
    function getDefaultProfileName() { return localStorage.getItem(LS_DEFAULT) || null; }
    function setDefaultProfileName(name) { localStorage.setItem(LS_DEFAULT, name); }

    function populateSavedProfilesSelect() {
      const sel = document.getElementById('savedProfiles');
      sel.innerHTML = '';
      const saved = loadSavedProfiles();
      const names = Object.keys(saved).sort();
      for (const n of names) {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      }
    }

    function fitTo(b) {
      const sw = L.latLng(b.minLat, b.minLon);
      const ne = L.latLng(b.maxLat, b.maxLon);
      map.fitBounds(L.latLngBounds(sw, ne));
    }

    function drawBbox(b, editable=false) {
      if (bboxRect) { map.removeLayer(bboxRect); bboxRect = null; }
      const show = document.getElementById('showbbox').checked;
      if (!show) return;
      const sw = L.latLng(b.minLat, b.minLon);
      const ne = L.latLng(b.maxLat, b.maxLon);
      bboxRect = L.rectangle([sw, ne], { weight: 1, dashArray: '4,4', fillOpacity: 0.03 });
      bboxRect.addTo(map);
      if (editable && bboxRect.editing && typeof bboxRect.editing.enable === 'function') {
        bboxRect.editing.enable();
        bboxRect.on('edit', () => {
          const bb = bboxRect.getBounds();
          const s = bb.getSouthWest();
          const n = bb.getNorthEast();
          setInputs({ minLat: s.lat, minLon: s.lng, maxLat: n.lat, maxLon: n.lng });
        });
      }
    }

    function setInputs(b) {
      document.getElementById('minLat').value = (b.minLat||'').toFixed ? b.minLat.toFixed(4) : b.minLat;
      document.getElementById('maxLat').value = (b.maxLat||'').toFixed ? b.maxLat.toFixed(4) : b.maxLat;
      document.getElementById('minLon').value = (b.minLon||'').toFixed ? b.minLon.toFixed(4) : b.minLon;
      document.getElementById('maxLon').value = (b.maxLon||'').toFixed ? b.maxLon.toFixed(4) : b.maxLon;
    }
    function getInputs() {
      return {
        minLat: parseFloat(document.getElementById('minLat').value),
        maxLat: parseFloat(document.getElementById('maxLat').value),
        minLon: parseFloat(document.getElementById('minLon').value),
        maxLon: parseFloat(document.getElementById('maxLon').value)
      };
    }

    function currentBbox() {
      const sel = document.getElementById('bbox').value;
      if (sel === 'custom') {
        const v = getInputs();
        return {
          minLat: v.minLat || DEFAULTS.minLat,
          maxLat: v.maxLat || DEFAULTS.maxLat,
          minLon: v.minLon || DEFAULTS.minLon,
          maxLon: v.maxLon || DEFAULTS.maxLon
        };
      }
      const saved = loadSavedProfiles();
      if (saved[sel]) return saved[sel];
      return BASE_PROFILES[sel] || BASE_PROFILES.gewenst;
    }

    (function initDefaultProfile() {
      populateSavedProfilesSelect();
      const def = getDefaultProfileName();
      const baseNames = ['gewenst','normaal','smal','ruim','custom'];
      const sel = document.getElementById('bbox');
      if (def && !baseNames.includes(def)) {
        const opt = document.createElement('option');
        opt.value = def; opt.textContent = def + ' (saved)';
        sel.insertBefore(opt, sel.firstChild);
        sel.value = def;
        const b = currentBbox();
        setInputs(b);
        fitTo(b); drawBbox(b, false);
      } else {
        fitTo(BASE_PROFILES.gewenst); drawBbox(BASE_PROFILES.gewenst);
        setInputs(BASE_PROFILES.gewenst);
      }
    })();

    function fmt(n, d=1){ return (n==null || Number.isNaN(n)) ? '–' : Number(n).toFixed(d); }
    const vf = (mmsi) => `https://www.vesselfinder.com/?mmsi=${encodeURIComponent(mmsi)}`;

    async function snapshot(bbox, windowMs=6000) {
      const url = new URL('/.netlify/functions/ais-snapshot', window.location.origin);
      Object.entries({ ...bbox, windowMs }).forEach(([k,v]) => url.searchParams.set(k, v));
      const t0 = performance.now();
      const res = await fetch(url, { cache: 'no-store' });
      const latency = Math.round(performance.now() - t0);
      document.getElementById('latency').textContent = latency;
      if (!res.ok) throw new Error(`http ${res.status}`);
      return res.json();
    }

    function updateStore(items, bbox) {
      const now = Date.now();
      TRAIL_LEN = Math.min(Math.max(parseInt(document.getElementById('trailLen').value,10)||(isMobile?6:8),3),30);
      for (const v of items) {
        if (!v.mmsi) continue;
        const prev = STORE.get(v.mmsi) || {};
        const trail = (prev.trail || []).slice(-TRAIL_LEN + 1);
        trail.push([v.lat, v.lon]);
        STORE.set(v.mmsi, { ...prev, ...v, lastSeen: now, trail });
      }
      for (const [mmsi, rec] of STORE) {
        const expired = now - (rec.lastSeen || 0) > TTL_MS;
        const outside = rec.lat < bbox.minLat || rec.lat > bbox.maxLat
                     || rec.lon < bbox.minLon || rec.lon > bbox.maxLon;
        if (expired || outside) {
          STORE.delete(mmsi);
          const mk = markers.get(mmsi); if (mk) { map.removeLayer(mk); markers.delete(mmsi); }
          const pl = trails.get(mmsi);  if (pl) { map.removeLayer(pl); trails.delete(mmsi); }
          const ar = arrows.get(mmsi);  if (ar) { map.removeLayer(ar); arrows.delete(mmsi); }
        }
      }
    }

    // --- Filter logic ---
    function applyFilter(items) {
      if (SHOW_ALL) return items; // show everything
      // hide moored: require valid SOG and > 0.8 kn
      return items.filter(v => {
        const hasSog = v.sog !== null && v.sog !== undefined && !Number.isNaN(v.sog);
        return hasSog && v.sog > 0.8;
      });
    }

    function renderList(items) {
      const el = document.getElementById('list');
      el.innerHTML = '';
      items.sort((a,b) => (b.sog||0)-(a.sog||0));
      for (const v of items) {
        const age = Date.now() - (v.lastSeen||0);
        const frac = Math.min(Math.max(age / TTL_MS, 0), 1);
        const dim = (1 - frac).toFixed(2);
        const div = document.createElement('div');
        div.className = 'list-item';
        div.style.opacity = dim;
        const since = Math.round(age/1000);
        const sogTxt = (v.sog==null || Number.isNaN(v.sog)) ? '–' : fmt(v.sog);
        div.textContent = `${v.name || 'unknown'} · MMSI ${v.mmsi || '–'} · SOG ${sogTxt} kn · COG ${fmt(v.cog)} · ${since}s ago`;
        div.onclick = () => {
          const m = markers.get(v.mmsi);
          if (m) { map.setView(m.getLatLng(), 16); m.openPopup(); }
          if (isMobile) toggleDrawer(false);
        };
        el.appendChild(div);
      }
      document.getElementById('count').textContent = String(items.length);
    }

    function endpointFromCog(lat, lon, cogDeg, meters=100) {
      if (!Number.isFinite(cogDeg)) return [lat, lon];
      const R = 6378137;
      const brng = cogDeg * Math.PI/180;
      const lat1 = lat * Math.PI/180;
      const lon1 = lon * Math.PI/180;
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(meters/R) + Math.cos(lat1)*Math.sin(meters/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(meters/R)*Math.cos(lat1), Math.cos(meters/R)-Math.sin(lat1)*Math.sin(lat2));
      return [lat2*180/Math.PI, lon2*180/Math.PI];
    }

    function renderGraphics(items) {
      const now = Date.now();
      for (const v of items) {
        const latlng = [v.lat, v.lon];
        const age = now - (v.lastSeen||0);
        const frac = Math.min(Math.max(age / TTL_MS, 0), 1);
        const opacity = Math.max(0.25, 1 - frac * 0.85);
        const radius = isMobile ? 7 : 6;

        const popup = `<strong>${v.name || 'unknown'}</strong><br/>MMSI: ${v.mmsi || '–'}<br/>Type: ${v.type || '–'}<br/>SOG: ${fmt(v.sog)} kn<br/>COG: ${fmt(v.cog)}°<br/><a href="${vf(v.mmsi||'')}" target="_blank" rel="noopener">open in vesselfinder</a>`;

        let mk = markers.get(v.mmsi);
        if (mk) {
          mk.setLatLng(latlng).setStyle({ opacity, fillOpacity: opacity, radius });
          mk.bindPopup(popup);
        } else {
          mk = L.circleMarker(latlng, { radius, weight: 1.5, opacity, fillOpacity: opacity });
          mk.addTo(map).bindPopup(popup);
          markers.set(v.mmsi, mk);
        }

        // trail
        let pl = trails.get(v.mmsi);
        const tl = (v.trail || []).map(([la,lo]) => [la,lo]);
        if (pl) {
          pl.setLatLngs(tl).setStyle({ opacity: Math.max(0.2, opacity - 0.2) });
        } else {
          pl = L.polyline(tl, { weight: 2, opacity: 0.6 });
          pl.addTo(map);
          trails.set(v.mmsi, pl);
        }

        // arrow
        let ar = arrows.get(v.mmsi);
        const end = endpointFromCog(v.lat, v.lon, v.cog, 100);
        if (ar) {
          ar.setLatLngs([latlng, end]).setStyle({ opacity: Math.max(0.3, opacity) });
        } else {
          ar = L.polyline([latlng, end], { weight: 2, opacity: 0.8 });
          ar.addTo(map);
          arrows.set(v.mmsi, ar);
        }
      }
    }

    function status(msg, isError=false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = isError ? 'error' : '';
    }

    function currentIntervalMs() { return Math.min(Math.max(parseInt(document.getElementById('interval').value,10)||5,2),60)*1000; }

    function renderAll() {
      const active = Array.from(STORE.values());
      const filtered = applyFilter(active);
      renderGraphics(filtered);
      renderList(filtered);
      document.getElementById('mode').textContent = SHOW_ALL ? 'show all' : 'hide moored';
    }

    async function tick() {
      const bbox = currentBbox();
      try {
        const res = await snapshot(bbox, 6000);
        status(`ok (${res.count})`);
        updateStore(res.data || [], bbox);
        // schedule drawing
        requestAnimationFrame(renderAll);
      } catch (e) {
        status(`function not reachable (${e.message}). demo mode`, true);
        demoOnce();
      }
    }

    function start() {
      if (pollTimer) return;
      // on mobile start with drawer closed + hide moored (unless restored)
      toggleDrawer(DRAWER_OPEN);
      setActiveButtons();
      TTL_MS = Math.min(Math.max((parseInt(document.getElementById('ttl').value,10)||(isMobile?35:45))*1000, 5000), 600000);
      document.getElementById('start').disabled = true;
      document.getElementById('stop').disabled = false;
      tick();
      pollTimer = setInterval(tick, currentIntervalMs());
    }

    function stop() {
      if (!pollTimer) return;
      clearInterval(pollTimer);
      pollTimer = null;
      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;
      status('stopped');
    }

    function setActiveButtons() {
      document.getElementById('presetHide').classList.toggle('active', !SHOW_ALL);
      document.getElementById('presetShow').classList.toggle('active', SHOW_ALL);
    }

    // Drawer
    function toggleDrawer(open) {
      const panel = document.getElementById('panel');
      if (open === undefined) open = !panel.classList.contains('open');
      if (open) panel.classList.add('open'); else panel.classList.remove('open');
      try { localStorage.setItem(LS_DRAWER, open ? 'open' : 'closed'); } catch {}
    }

    // Event handlers
    document.getElementById('burger').onclick = () => toggleDrawer();

    document.getElementById('start').onclick = start;
    document.getElementById('stop').onclick = stop;
    document.getElementById('bbox').onchange = () => {
      const sel = document.getElementById('bbox').value;
      document.getElementById('customPanel').style.display = (sel === 'custom') ? 'block' : 'none';
      const b = currentBbox();
      fitTo(b);
      drawBbox(b, sel === 'custom');
      if (sel !== 'custom') setInputs(b);
    };
    document.getElementById('showbbox').onchange = () => { drawBbox(currentBbox(), document.getElementById('bbox').value === 'custom'); };
    document.getElementById('presetHide').onclick = () => {
      SHOW_ALL = false;
      setActiveButtons();
      try { localStorage.setItem(LS_MODE, 'hide'); } catch {}
      renderAll();
    };
    document.getElementById('presetShow').onclick = () => {
      SHOW_ALL = true;
      setActiveButtons();
      try { localStorage.setItem(LS_MODE, 'show'); } catch {}
      renderAll();
    };

    document.getElementById('applyFromMap').onclick = () => {
      if (!bboxRect) return;
      const bb = bboxRect.getBounds();
      const s = bb.getSouthWest();
      const n = bb.getNorthEast();
      setInputs({ minLat: s.lat, minLon: s.lng, maxLat: n.lat, maxLon: n.lng });
    };
    document.getElementById('applyToMap').onclick = () => {
      const b = currentBbox();
      drawBbox(b, true);
      fitTo(b);
    };

    // profile save/load/delete/default
    function loadSavedProfilesSelect() {
      const sel = document.getElementById('savedProfiles');
      sel.innerHTML = '';
      const saved = loadSavedProfiles();
      const names = Object.keys(saved).sort();
      for (const n of names) {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n;
        sel.appendChild(opt);
      }
    }
    document.getElementById('saveProfile').onclick = () => {
      const name = (document.getElementById('profileName').value || '').trim();
      if (!name) return alert('enter a profile name');
      const vals = getInputs();
      const saved = loadSavedProfiles();
      saved[name] = vals;
      saveSavedProfiles(saved);
      loadSavedProfilesSelect();
      const sel = document.getElementById('bbox');
      let opt = Array.from(sel.options).find(o => o.value === name);
      if (!opt) {
        opt = document.createElement('option');
        opt.value = name; opt.textContent = name + ' (saved)';
        sel.appendChild(opt);
      }
      sel.value = name;
      const b = currentBbox();
      fitTo(b); drawBbox(b);
    };
    document.getElementById('setDefault').onclick = () => {
      const sel = document.getElementById('bbox').value;
      if (sel === 'custom') return alert('save the custom profile first');
      setDefaultProfileName(sel);
      alert('default profile set: ' + sel);
    };
    document.getElementById('deleteProfile').onclick = () => {
      const selSaved = document.getElementById('savedProfiles').value;
      if (!selSaved) return;
      const saved = loadSavedProfiles();
      delete saved[selSaved];
      saveSavedProfiles(saved);
      loadSavedProfilesSelect();
      const mainSel = document.getElementById('bbox');
      for (const o of Array.from(mainSel.options)) {
        if (o.value === selSaved) { mainSel.removeChild(o); break; }
      }
    };
    document.getElementById('savedProfiles').onchange = (e) => {
      const name = e.target.value;
      const saved = loadSavedProfiles();
      if (saved[name]) {
        setInputs(saved[name]);
        const mainSel = document.getElementById('bbox');
        let opt = Array.from(mainSel.options).find(o => o.value === name);
        if (!opt) {
          opt = document.createElement('option');
          opt.value = name; opt.textContent = name + ' (saved)';
          mainSel.appendChild(opt);
        }
        mainSel.value = name;
        const b = currentBbox();
        fitTo(b); drawBbox(b);
      }
    };

    // initialise custom panel with current bbox
    loadSavedProfilesSelect();
    setInputs(BASE_PROFILES.gewenst);
    document.getElementById('customPanel').style.display = (document.getElementById('bbox').value === 'custom') ? 'block' : 'none';
    if (DRAWER_OPEN) document.getElementById('panel').classList.add('open');

    function demoOnce() {
      const b = currentBbox();
      const rnd = (min, max) => min + Math.random() * (max - min);
      const names = ['Demo I', 'Demo II', 'Demo III', 'Demo IV'];
      const now = Date.now();
      const items = names.map((n, i) => ({
        mmsi: `999000${i+1}`,
        name: n,
        lat: rnd(b.minLat, b.maxLat),
        lon: rnd(b.minLon, b.maxLon),
        sog: Math.round(rnd(0, 18)*10)/10,
        cog: Math.round(rnd(0, 359)),
        type: 'Demo',
        ts: now,
        lastSeen: now,
        trail: [[rnd(b.minLat, b.maxLat), rnd(b.minLon, b.maxLon)]]
      }));
      for (const v of items) STORE.set(v.mmsi, v);
      renderAll();
    }
  </script>
</body>
</html>
